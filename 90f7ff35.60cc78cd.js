(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{77:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return i})),n.d(t,"metadata",(function(){return r})),n.d(t,"rightToc",(function(){return s})),n.d(t,"default",(function(){return c}));var o=n(2),l=n(6),a=(n(0),n(94)),i={title:"Selectors"},r={id:"basic-tutorial/selectors",isDocsHomePage:!1,title:"Selectors",description:"A selector represents a piece of derived state. You can think of derived state as the output of passing state to a function that modifies the given state in some way.",source:"@site/docs/basic-tutorial/selectors.md",permalink:"/statex/docs/basic-tutorial/selectors",editUrl:"https://github.com/CloudIOInc/statex/edit/master/website/docs/basic-tutorial/selectors.md",sidebar:"someSidebar",previous:{title:"Atoms",permalink:"/statex/docs/basic-tutorial/atoms"},next:{title:"Selectors",permalink:"/statex/docs/basic-tutorial/actions"}},s=[{value:"Demo",id:"demo",children:[]}],d={rightToc:s};function c(e){var t=e.components,n=Object(l.a)(e,["components"]);return Object(a.b)("wrapper",Object(o.a)({},d,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("p",null,"A ",Object(a.b)("strong",{parentName:"p"},"selector")," represents a piece of ",Object(a.b)("strong",{parentName:"p"},"derived state"),". You can think of derived state as the output of passing state to a function that modifies the given state in some way."),Object(a.b)("p",null,"Derived state is a powerful concept because it lets us build dynamic data that depends on other data. In the context of our todo list application, the following are considered derived state:"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("strong",{parentName:"li"},"Filtered todo list"),": derived from the complete todo list by creating a new list that has certain items filtered out based on some criteria (such as filtering out items that are already completed)."),Object(a.b)("li",{parentName:"ul"},Object(a.b)("strong",{parentName:"li"},"Todo list statistics"),": derived from the complete todo list by calculating useful attributes of the list, such as the total number of items in the list, the number of completed items, and the percentage of items that are completed.")),Object(a.b)("p",null,'To implement a filtered todo list, we need to choose a set of filter criteria whose value can be saved in an atom. The filter options we\'ll use are: "Show All", "Show Completed", and "Show Uncompleted". The default value will be "Show All":'),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-javascript"}),"const todoFilterAtom = atom({\n  path: ['todo', 'filter'],\n  defaultValue: 'Show All',\n});\n")),Object(a.b)("p",null,"Using ",Object(a.b)("inlineCode",{parentName:"p"},"todoFilterAtom")," and ",Object(a.b)("inlineCode",{parentName:"p"},"todoList"),", we can build a ",Object(a.b)("inlineCode",{parentName:"p"},"todoFilteredIds")," selector which derives a filtered list:"),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-javascript"}),"const todoFilteredIds = selector({\n  path: ['todo', 'filteredIds'],\n  defaultValue: [],\n  get: ({ get }) => {\n    const filter = get(todoFilterAtom);\n    const all = get(todoList);\n    let list = all;\n    switch (filter) {\n      case 'Show Completed':\n        list = list.filter((item) => item.isComplete);\n        break;\n      case 'Show Uncompleted':\n        list = list.filter((item) => !item.isComplete);\n        break;\n    }\n    return list.map((todo) => all.indexOf(todo));\n  },\n});\n")),Object(a.b)("p",null,"The ",Object(a.b)("inlineCode",{parentName:"p"},"todoFilteredIds")," internally keeps track of two dependencies: ",Object(a.b)("inlineCode",{parentName:"p"},"todoFilterAtom")," and ",Object(a.b)("inlineCode",{parentName:"p"},"todoList")," so that it re-runs if either of those change."),Object(a.b)("blockquote",null,Object(a.b)("p",{parentName:"blockquote"},"From a component's point of view, selectors can be read using the same hooks that are used to read atoms. However it's important to note that certain hooks only work with ",Object(a.b)("strong",{parentName:"p"},"writable state")," (i.e ",Object(a.b)("inlineCode",{parentName:"p"},"useStateX()"),"). All atoms are writable state, but only some selectors are considered writable state (selectors that have both a ",Object(a.b)("inlineCode",{parentName:"p"},"get")," and ",Object(a.b)("inlineCode",{parentName:"p"},"set")," property). See the ",Object(a.b)("a",Object(o.a)({parentName:"p"},{href:"../introduction/core-concepts"}),"Core Concepts")," page for more information on this topic.")),Object(a.b)("p",null,"Displaying our filtered todoList is as simple as changing one line in the ",Object(a.b)("inlineCode",{parentName:"p"},"TodoList")," component:"),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-jsx"}),"function TodoList() {\n  // changed from todoList to todoFilteredIds\n  const todoList = useStateXValue(todoFilteredIds);\n\n  return (\n    <>\n      <TodoListStats />\n      <TodoListFilters />\n      <TodoItemCreator />\n\n      {todoList.map((todoItem) => (\n        <TodoItem item={todoItem} key={todoItem.id} />\n      ))}\n    </>\n  );\n}\n")),Object(a.b)("p",null,"Note the UI is the same as the ",Object(a.b)("inlineCode",{parentName:"p"},"todoFilterAtom")," has a default of ",Object(a.b)("inlineCode",{parentName:"p"},'"Show All"'),". In order to change the filter, we need to implement the ",Object(a.b)("inlineCode",{parentName:"p"},"TodoListFilters")," component:"),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-jsx"}),'function TodoListFilters() {\n  const [filter, setFilter] = useStateX(todoFilterAtom);\n\n  const updateFilter = ({ target: { value } }) => {\n    setFilter(value);\n  };\n\n  return (\n    <>\n      Filter:\n      <select value={filter} onChange={updateFilter}>\n        <option value="Show All">All</option>\n        <option value="Show Completed">Completed</option>\n        <option value="Show Uncompleted">Uncompleted</option>\n      </select>\n    </>\n  );\n}\n')),Object(a.b)("p",null,"With a few lines of code we've managed to implement filtering! We'll use the same concepts to implement the ",Object(a.b)("inlineCode",{parentName:"p"},"TodoListStats")," component."),Object(a.b)("p",null,"We want to display the following stats:"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"Total number of todo items"),Object(a.b)("li",{parentName:"ul"},"Total number of completed items"),Object(a.b)("li",{parentName:"ul"},"Total number of uncompleted items"),Object(a.b)("li",{parentName:"ul"},"Percentage of items completed")),Object(a.b)("p",null,"While we could create a selector for each of the stats, an easier approach would be to create one selector that returns an object containing the data we need. We'll call this selector ",Object(a.b)("inlineCode",{parentName:"p"},"todoListStatsState"),":"),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-javascript"}),"const todoListStatsState = selector({\n  key: 'todoListStatsState',\n  get: ({ get }) => {\n    const todoList = get(todoFilteredIds);\n    const totalNum = todoList.length;\n    const totalCompletedNum = todoList.filter((item) => item.isComplete).length;\n    const totalUncompletedNum = totalNum - totalCompletedNum;\n    const percentCompleted = totalNum === 0 ? 0 : totalCompletedNum / totalNum;\n\n    return {\n      totalNum,\n      totalCompletedNum,\n      totalUncompletedNum,\n      percentCompleted,\n    };\n  },\n});\n")),Object(a.b)("p",null,"To read the value of ",Object(a.b)("inlineCode",{parentName:"p"},"todoListStatsState"),", we use ",Object(a.b)("inlineCode",{parentName:"p"},"useStateXValue()")," once again:"),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-jsx"}),"function TodoListStats() {\n  const {\n    totalNum,\n    totalCompletedNum,\n    totalUncompletedNum,\n    percentCompleted,\n  } = useStateXValue(todoListStatsState);\n\n  const formattedPercentCompleted = Math.round(percentCompleted * 100);\n\n  return (\n    <ul>\n      <li>Total items: {totalNum}</li>\n      <li>Items completed: {totalCompletedNum}</li>\n      <li>Items not completed: {totalUncompletedNum}</li>\n      <li>Percent completed: {formattedPercentCompleted}</li>\n    </ul>\n  );\n}\n")),Object(a.b)("p",null,"To summarize, we've created a todo list app that meets all of our requirements:"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"Add todo items"),Object(a.b)("li",{parentName:"ul"},"Edit todo items"),Object(a.b)("li",{parentName:"ul"},"Delete todo items"),Object(a.b)("li",{parentName:"ul"},"Filter todo items"),Object(a.b)("li",{parentName:"ul"},"Display useful stats")),Object(a.b)("h2",{id:"demo"},"Demo"),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-jsx",metastring:"live",live:!0}),"const initialTodos = [\n  { id: 100, text: 'Learn Javascript', isComplete: true },\n  { id: 101, text: 'Learn React', isComplete: true },\n  { id: 102, text: \"Use CloudIO's StateX\" },\n  { id: 103, text: 'Launch Product' },\n];\n\nconst todoList = atom({\n  path: ['todo', 'list'],\n  defaultValue: initialTodos,\n});\n\nconst todoFilterAtom = atom({\n  path: ['todo', 'filter'],\n  defaultValue: 'Show All',\n});\n\nconst todoFilteredIds = selector({\n  path: ['todo', 'filteredIds'],\n  defaultValue: [],\n  get: ({ get }) => {\n    const filter = get(todoFilterAtom);\n    const all = get(todoList);\n    let list = all;\n    switch (filter) {\n      case 'Show Completed':\n        list = list.filter((item) => item.isComplete);\n        break;\n      case 'Show Uncompleted':\n        list = list.filter((item) => !item.isComplete);\n        break;\n    }\n    return list.map((todo) => ({ id: todo.id, index: all.indexOf(todo) }));\n  },\n});\n\nconst todoListStatsState = selector({\n  path: ['todo', 'stats'],\n  defaultValue: {\n    totalNum: 0,\n    totalCompletedNum: 0,\n    totalUncompletedNum: 0,\n    percentCompleted: 0,\n  },\n  get: ({ get }) => {\n    const list = get(todoList);\n    const totalNum = list.length;\n    const totalCompletedNum = list.filter((item) => item.isComplete).length;\n    const totalUncompletedNum = totalNum - totalCompletedNum;\n    const percentCompleted = totalNum === 0 ? 0 : totalCompletedNum / totalNum;\n\n    return {\n      totalNum,\n      totalCompletedNum,\n      totalUncompletedNum,\n      percentCompleted,\n    };\n  },\n  shouldComponentUpdate: (value, oldValue) => {\n    return (\n      !oldValue ||\n      value.totalNum !== oldValue.totalNum ||\n      value.totalCompletedNum !== oldValue.totalCompletedNum ||\n      value.totalUncompletedNum !== oldValue.totalUncompletedNum ||\n      value.percentCompleted !== oldValue.percentCompleted\n    );\n  },\n});\n\nconst ToDoList = memo(() => {\n  return (\n    <>\n      <TodoListStats />\n      <TodoListFilters />\n      <TodoItemCreator />\n      <TodoList />\n      <JSONPreview />\n    </>\n  );\n});\n\nfunction JSONPreview() {\n  const todoList = useStateXValue(['todo'], []);\n  return <pre>{JSON.stringify(todoList, null, '  ')}</pre>;\n}\n\nfunction TodoList() {\n  const filteredIds = useStateXValue(todoFilteredIds, {\n    shouldComponentUpdate: (ids, oldIds) => {\n      return JSON.stringify(ids) !== JSON.stringify(oldIds);\n    },\n  });\n\n  return (\n    <>\n      {filteredIds.map((entry) => (\n        <TodoItem index={entry.index} key={entry.id} />\n      ))}\n    </>\n  );\n}\n\nfunction TodoItemCreator() {\n  const [inputValue, setInputValue] = useState('');\n  const setTodoList = useStateXValueSetter(todoList);\n\n  const addItem = () => {\n    setTodoList((oldTodoList) => [\n      ...oldTodoList,\n      {\n        id: getId(),\n        text: inputValue,\n      },\n    ]);\n    setInputValue('');\n  };\n\n  const onChange = ({ target: { value } }) => {\n    setInputValue(value);\n  };\n\n  return (\n    <div>\n      <input type=\"text\" value={inputValue} onChange={onChange} />\n      <button onClick={addItem}>Add</button>\n    </div>\n  );\n}\n\nfunction TodoItem({ index }) {\n  const [text, setText] = useStateX(['todo', 'list', ':index', 'text'], '', {\n    params: { index },\n  });\n  const [isComplete, setIsComplete] = useStateX(\n    ['todo', 'list', ':index', 'isComplete'],\n    false,\n    { params: { index } },\n  );\n\n  const deleteItem = useStateXValueRemover(['todo', 'list', ':index'], {\n    params: { index },\n  });\n\n  return (\n    <div>\n      <input\n        type=\"text\"\n        value={text}\n        onChange={(e) => setText(e.target.value)}\n      />\n      <input\n        checked={isComplete}\n        type=\"checkbox\"\n        onChange={(e) => setIsComplete(e.target.checked)}\n      />\n      <button onClick={deleteItem}>X</button>\n    </div>\n  );\n}\n\nfunction TodoListFilters() {\n  const filter = useStateXForSelect(todoFilterAtom);\n\n  return (\n    <>\n      Filter:\n      <select {...filter}>\n        <option value=\"Show All\">All</option>\n        <option value=\"Show Completed\">Completed</option>\n        <option value=\"Show Uncompleted\">Uncompleted</option>\n      </select>\n    </>\n  );\n}\n\nfunction TodoListStats() {\n  const {\n    totalNum,\n    totalCompletedNum,\n    totalUncompletedNum,\n    percentCompleted,\n  } = useStateXValue(todoListStatsState);\n\n  const formattedPercentCompleted = Math.round(percentCompleted * 100);\n\n  return (\n    <ul>\n      <li>Total items: {totalNum}</li>\n      <li>Items completed: {totalCompletedNum}</li>\n      <li>Items not completed: {totalUncompletedNum}</li>\n      <li>Percent completed: {formattedPercentCompleted}</li>\n    </ul>\n  );\n}\n\nlet id = 104;\nfunction getId() {\n  return id++;\n}\n\nreturn <ToDoList />;\n")))}c.isMDXComponent=!0},94:function(e,t,n){"use strict";n.d(t,"a",(function(){return m})),n.d(t,"b",(function(){return b}));var o=n(0),l=n.n(o);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,l=function(e,t){if(null==e)return{};var n,o,l={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(l[n]=e[n]);return l}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(l[n]=e[n])}return l}var d=l.a.createContext({}),c=function(e){var t=l.a.useContext(d),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},m=function(e){var t=c(e.components);return l.a.createElement(d.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return l.a.createElement(l.a.Fragment,{},t)}},u=l.a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,i=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),m=c(n),u=o,b=m["".concat(i,".").concat(u)]||m[u]||p[u]||a;return n?l.a.createElement(b,r(r({ref:t},d),{},{components:n})):l.a.createElement(b,r({ref:t},d))}));function b(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,i=new Array(a);i[0]=u;var r={};for(var s in t)hasOwnProperty.call(t,s)&&(r[s]=t[s]);r.originalType=e,r.mdxType="string"==typeof e?e:o,i[1]=r;for(var d=2;d<a;d++)i[d]=n[d];return l.a.createElement.apply(null,i)}return l.a.createElement.apply(null,n)}u.displayName="MDXCreateElement"}}]);