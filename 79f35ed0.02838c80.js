(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{76:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return c})),n.d(t,"metadata",(function(){return r})),n.d(t,"rightToc",(function(){return s})),n.d(t,"default",(function(){return u}));var a=n(2),o=n(6),i=(n(0),n(96)),c={title:"Core Concepts"},r={id:"introduction/core-concepts",isDocsHomePage:!1,title:"Core Concepts",description:"Overview",source:"@site/docs/introduction/core-concepts.mdx",permalink:"/statex/docs/introduction/core-concepts",editUrl:"https://github.com/CloudIOInc/statex/edit/master/website/docs/introduction/core-concepts.mdx",sidebar:"someSidebar",previous:{title:"Getting Started",permalink:"/statex/docs/"},next:{title:"Installation",permalink:"/statex/docs/introduction/installation"}},s=[{value:"Overview",id:"overview",children:[]},{value:"Path",id:"path",children:[{value:"Demo",id:"demo",children:[]}]},{value:"Atoms",id:"atoms",children:[{value:"Demo",id:"demo-1",children:[]}]},{value:"Selectors",id:"selectors",children:[{value:"Demo",id:"demo-2",children:[]}]},{value:"Actions",id:"actions",children:[{value:"Demo",id:"demo-3",children:[]}]}],l={rightToc:s};function u(e){var t=e.components,n=Object(o.a)(e,["components"]);return Object(i.b)("wrapper",Object(a.a)({},l,n,{components:t,mdxType:"MDXLayout"}),Object(i.b)("h2",{id:"overview"},"Overview"),Object(i.b)("p",null,"StateX lets you create a react based application with a flexible state management solution. Atoms are units of state that components can subscribe to. Selectors transform this state either synchronously or asynchronously."),Object(i.b)("h2",{id:"path"},"Path"),Object(i.b)("blockquote",null,Object(i.b)("p",{parentName:"blockquote"},Object(i.b)("inlineCode",{parentName:"p"},"( string | number )[]"))),Object(i.b)("p",null,"Path points to a unit of state. You can use path to read or write any\nnode in your state tree. Path can be dynamic and constructed on the fly.\nStateX (aka State) tree is immutable. When an atom is updated, each\nsubscribed component is re-rendered with the new value."),Object(i.b)("h3",{id:"demo"},"Demo"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-jsx",metastring:"live open",live:!0,open:!0}),"useWithStateX({ \n  person: {firstName: 'CloudIO', lastName: 'StateX'} \n});\n\nconst value = useStateXValue(['person', 'firstName']); \n// try changing the above path to ['person']\n\nreturn JSON.stringify(value);\n")),Object(i.b)("h2",{id:"atoms"},"Atoms"),Object(i.b)("p",null,"Atoms are units of state at a specific path. They're updateable and subscribable:\nwhen an atom is updated, each subscribed component is re-rendered with the new value.\nThey can be created at runtime, too. Atoms can be used in place of React local\ncomponent state. If the same atom is used from multiple components, all those\ncomponents share the same unit of state."),Object(i.b)("p",null,"Atoms are created using the ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../api-reference/core/atom"}),"atom()")," function:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"const fontSizeStateX = atom({\n  path: ['ui', 'fontSize'],\n  defaultValue: 11,\n});\n")),Object(i.b)("p",null,"Atoms need a unique path, which is used for building the state JSON\nobject with each segment in the path becoming the object key. Nested\nobjects can be created with mulitiple segments in the path. It is an\nerror for two atoms to have the same path, so make sure they're\nglobally unique. Like React component state, they also have a default value."),Object(i.b)("p",null,"To read and write an atom from a component, we use a hook called ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../api-reference/core/useStateX"}),"useStateX"),".\nIt's just like React's ",Object(i.b)("inlineCode",{parentName:"p"},"useState"),", but now the state can be shared between components:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-jsx"}),"function FontButton() {\n  const [fontSize, setFontSize] = useStateX(fontSizeStateX);\n  return (\n    <button\n      onClick={() => setFontSize((size) => size + 1)}\n      style={{ fontSize }}\n    >\n      Click to Enlarge\n    </button>\n  );\n}\n")),Object(i.b)("p",null,"Clicking on the button will increase the font size of the button by one.\nBut now some other component can also use the same font size:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-jsx"}),"function Text() {\n  const [fontSize, setFontSize] = useStateX(fontSizeStateX);\n  return <p style={{ fontSize }}>This text will increase in size too.</p>;\n}\n")),Object(i.b)("h3",{id:"demo-1"},"Demo"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-jsx",metastring:"live",live:!0}),"const fontSizeStateX = atom({\n  path: ['ui', 'fontSize'],\n  defaultValue: 11,\n});\n\nfunction FontButton() {\n  const [fontSize, setFontSize] = useStateX(fontSizeStateX);\n  return (\n    <button\n      onClick={() => setFontSize((size) => size + 1)}\n      style={{ fontSize }}\n    >\n      Click to Enlarge\n    </button>\n  );\n}\n\nfunction Text() {\n  const [fontSize, setFontSize] = useStateX(fontSizeStateX);\n  return <p style={{ fontSize }}>This text will increase in size too.</p>;\n}\n\nreturn <><FontButton/><Text/></>;\n")),Object(i.b)("h2",{id:"selectors"},"Selectors"),Object(i.b)("p",null,"A ",Object(i.b)("strong",{parentName:"p"},"selector")," is a pure function that accepts atoms or other selectors as input.\nWhen these upstream atoms or selectors are updated, the selector function will be re-evaluated.\nComponents can subscribe to selectors just like atoms, and will then be re-rendered when the selectors change."),Object(i.b)("p",null,"Selectors are used to calculate derived data that is based on state. This lets us avoid redundant\nstate, usually obviating the need for reducers to keep state in sync and valid. Instead, a minimal\nset of state is stored in atoms, while everything else is efficiently computed as a function of\nthat minimal state. Since selectors keep track of what components need them and what state they\ndepend on, they make this functional approach more efficient."),Object(i.b)("p",null,"From the point of view of components, selectors and atoms have the same interface and can\ntherefore be substituted for one another."),Object(i.b)("p",null,"Selectors are defined using the ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../api-reference/core/selector"}),"selector()")," function:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"const fontSizeLabelStateX = selector({\n  path: ['fontSizeLabelStateX'],\n  get: ({ get }) => {\n    const fontSize = get(fontSizeStateX);\n    const unit = 'px';\n\n    return `${fontSize}${unit}`;\n  },\n});\n")),Object(i.b)("p",null,"The ",Object(i.b)("inlineCode",{parentName:"p"},"get")," property is the function that is to be computed. It can access\nthe value of any path, atoms and other selectors using the ",Object(i.b)("inlineCode",{parentName:"p"},"get")," argument\npassed to it. Whenever it accesses another path, atom or selector, a\ndependency relationship is created such that updating the other atom or\nselector will cause this one to be recomputed."),Object(i.b)("p",null,"In this ",Object(i.b)("inlineCode",{parentName:"p"},"['fontSizeLabelStateX']")," example, the selector has one dependency:\nthe ",Object(i.b)("inlineCode",{parentName:"p"},"['fontSizeStateX']")," atom. Conceptually, the ",Object(i.b)("inlineCode",{parentName:"p"},"['fontSizeLabelStateX']"),"\nselector behaves like a pure function that takes a ",Object(i.b)("inlineCode",{parentName:"p"},"['fontSizeStateX']")," as\ninput and returns a formatted font size label as output."),Object(i.b)("p",null,"Selectors can be read using ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../api-reference/core/useStateXValue"}),"useStateXValue()"),", which takes a, path, atom\nor selector as an argument and returns the corresponding value. We don't\nuse the ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../api-reference/core/useStateX"}),"useStateX()")," as the ",Object(i.b)("inlineCode",{parentName:"p"},"fontSizeLabelStateX")," selector is not\nwriteable (see the ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../api-reference/core/selector"}),"selector API reference"),"\nfor more information on writeable selectors):"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-jsx"}),"function FontButton() {\n  const [fontSize, setFontSize] = useStateX(fontSizeStateX);\n  const fontSizeLabel = useStateXValue(fontSizeLabelStateX);\n\n  return (\n    <>\n      <div>Current font size: ${fontSizeLabel}</div>\n\n      <button onClick={() => setFontSize(fontSize + 1)} style={{ fontSize }}>\n        Click to Enlarge\n      </button>\n    </>\n  );\n}\n")),Object(i.b)("p",null,"Clicking on the button now does two things: it increases the font size of the button while also updating the font size label to reflect the current font size."),Object(i.b)("h3",{id:"demo-2"},"Demo"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-jsx",metastring:"live",live:!0}),"const fontSizeStateX = atom({\n  path: ['ui', 'fontSize'],\n  defaultValue: 11,\n});\n\nconst fontSizeLabelStateX = selector({\n  path: ['fontSizeLabelStateX'],\n  get: ({ get }) => {\n    const fontSize = get(fontSizeStateX);\n    const unit = 'px';\n\n    return `${fontSize}${unit}`;\n  },\n});\n\nfunction FontButton() {\n  const [fontSize, setFontSize] = useStateX(fontSizeStateX);\n  const fontSizeLabel = useStateXValue(fontSizeLabelStateX);\n\n  return (\n    <>\n      <div>Current font size: {fontSizeLabel}</div>\n\n      <button onClick={() => setFontSize(fontSize + 1)} style={{ fontSize }}>\n        Click to Enlarge\n      </button>\n    </>\n  );\n}\n\nreturn <FontButton/>;\n")),Object(i.b)("h2",{id:"actions"},"Actions"),Object(i.b)("p",null,"An ",Object(i.b)("strong",{parentName:"p"},"action")," is a reusable pure function that has access to the StateX state\nand an ability to update the StateX state or invoke other actions.\nUnlike ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../api-reference/core/selector"}),"selector"),", actions will not subscribe to any changes to the\n",Object(i.b)("inlineCode",{parentName:"p"},"atoms")," or ",Object(i.b)("inlineCode",{parentName:"p"},"selectors")," it reads."),Object(i.b)("p",null,"Actions are used to keep multiple state updates in sync with some common, reusable logic.\nThis lets us avoid duplicate code and disconnected state. Since action have full access\nto the state, it can perform state updates asyncronusly as well. With actions, you can\nmodularize your business logic outside the component, thereby making the components lite weight."),Object(i.b)("p",null,"Actions are defined using the ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../api-reference/core/action"}),"action()")," function:"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"const activateNodeAction = action(({ get, set, call }, id: NodeID) => {\n  set(activeNodeIdAtom, id);\n  set(activeTabAtom, 1);\n});\n")),Object(i.b)("p",null,"The function passed to action is to be executed on demand. It can access\nthe value of any path, atoms, selectors using the ",Object(i.b)("inlineCode",{parentName:"p"},"get")," argument\npassed to it. It can update the state using the ",Object(i.b)("inlineCode",{parentName:"p"},"set")," argument and call any\nother action using the ",Object(i.b)("inlineCode",{parentName:"p"},"call")," argument."),Object(i.b)("p",null,"In this ",Object(i.b)("inlineCode",{parentName:"p"},"activateNodeAction")," example, the action updates two atom states to\nmark a given nodeId as active and also set a specific tab as active."),Object(i.b)("p",null,"Actions can be accessed using ",Object(i.b)("a",Object(a.a)({parentName:"p"},{href:"../api-reference/core/useStateXAction"}),"useStateXAction()"),", which takes the action\nas an argument and returns a callback function that can be invoked on user action."),Object(i.b)("h3",{id:"demo-3"},"Demo"),Object(i.b)("pre",null,Object(i.b)("code",Object(a.a)({parentName:"pre"},{className:"language-jsx",metastring:"live",live:!0}),"const activeNodeIdAtom = atom({\n  path: ['active', 'node'],\n  defaultValue: '',\n});\n\nconst activeTabAtom = atom({\n  path: ['active', 'tab'],\n  defaultValue: 0,\n});\n\nconst activateNodeAction = action(({ get, set, remove, call }, id) => {\n  set(activeNodeIdAtom, id);\n  set(activeTabAtom, 1);\n});\n\nfunction Tabs() {\n  const [activeTab, setActiveTab] = useStateX(activeTabAtom);\n\n  const style = {borderLeft: '4px solid #ddd', paddingLeft: 8};\n  const activeStyle = {...style, borderLeft: '4px solid blue'};\n\n  return (\n    <>\n      <div onClick={() => setActiveTab(0)} style={activeTab === 0 ? activeStyle : style}>Tab One</div>\n      <div onClick={() => setActiveTab(1)} style={activeTab === 1 ? activeStyle : style}>Tab Two</div>\n    </>\n  );\n}\n\nfunction Node({id}) {\n  const activeNodeId = useStateXValue(activeNodeIdAtom);\n  const activateNode = useStateXAction(activateNodeAction);\n\n  let style = activeNodeId === id ? {color: 'blue'} : {};\n\n  return (\n      <button style={style} onClick={() => activateNode(id)}>Node {id}</button>\n  );\n}\n\nfunction Nodes() {\n  const activeNodeId = useStateXValue(activeNodeIdAtom);\n  return (\n    <>\n      <div>Active Node: {activeNodeId || 'None'}</div>\n      <Node id=\"A\" />\n      <Node id=\"B\" />\n    </>\n  );\n}\n\nfunction App() {\n  return (<>\n    <Tabs />\n    <Nodes />\n  </>);\n}\n\nreturn <App/>;\n")))}u.isMDXComponent=!0},96:function(e,t,n){"use strict";n.d(t,"a",(function(){return b})),n.d(t,"b",(function(){return m}));var a=n(0),o=n.n(a);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function c(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?c(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):c(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=o.a.createContext({}),u=function(e){var t=o.a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},b=function(e){var t=u(e.components);return o.a.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return o.a.createElement(o.a.Fragment,{},t)}},d=o.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,c=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),b=u(n),d=a,m=b["".concat(c,".").concat(d)]||b[d]||p[d]||i;return n?o.a.createElement(m,r(r({ref:t},l),{},{components:n})):o.a.createElement(m,r({ref:t},l))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,c=new Array(i);c[0]=d;var r={};for(var s in t)hasOwnProperty.call(t,s)&&(r[s]=t[s]);r.originalType=e,r.mdxType="string"==typeof e?e:a,c[1]=r;for(var l=2;l<i;l++)c[l]=n[l];return o.a.createElement.apply(null,c)}return o.a.createElement.apply(null,n)}d.displayName="MDXCreateElement"}}]);